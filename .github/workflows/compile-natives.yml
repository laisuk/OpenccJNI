# filename: .github/workflows/compile-natives.yml
name: Compile OpenccJNI Natives

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  # JNI sources live alongside Java in the openccjni package dir
  CPP_SRC: openccjni/src/main/java/openccjni/OpenccWrapper.cpp
  JAVA_SRC_CLASS: openccjni/src/main/java/openccjni/OpenccWrapper.java

  # C headers (generated + capi header) live with java sources
  CAPI_INCLUDE: openccjni/src/main/java/openccjni

  # Link against the CAPI that is shipped under resources
  LINUX_LIB_DIR: openccjni/src/main/resources/openccjni/natives/linux-x86_64
  MACOS_ARM64_LIB_DIR: openccjni/src/main/resources/openccjni/natives/macos-arm64

  # Library name for -l<name> (maps to libopencc_fmmseg_capi.{so,dylib,a})
  CAPI_LIB_NAME: opencc_fmmseg_capi

jobs:
  native:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-14, windows-latest]
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Temurin JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - name: Install MinGW-w64 (+ gendef)
        run: |
          sudo apt-get update
          sudo apt-get install -y mingw-w64 mingw-w64-tools binutils-mingw-w64 zip
          command -v x86_64-w64-mingw32-g++ >/dev/null
          command -v x86_64-w64-mingw32-dlltool >/dev/null
          command -v gendef >/dev/null

      - name: Show tree for sanity
        if: ${{ runner.os != 'Windows' }}
        shell: bash
        run: |
          ls -la openccjni/src/main/java/openccjni || true
          ls -la "${{ env.LINUX_LIB_DIR }}" || true
          ls -la "${{ env.MACOS_ARM64_LIB_DIR }}" || true

      - name: Generate JNI header (optional)
        if: ${{ runner.os != 'Windows' }}
        shell: bash
        run: |
          set -euo pipefail
          # Generates openccjni_OpenccWrapper.h into repo root (CWD), as you already do
          javac -h . "${{ env.JAVA_SRC_CLASS }}"
          test -f openccjni_OpenccWrapper.h || (echo "JNI header not generated" && exit 1)

      - name: Build wrapper (Linux/macOS, static preferred)
        if: ${{ runner.os != 'Windows' }}
        shell: bash
        run: |
          set -euo pipefail

          # Pick platform settings
          case "${{ runner.os }}" in
            Linux)
              OUT=libOpenccWrapper.so
              LIB_DIR="${{ env.LINUX_LIB_DIR }}"
              JINC=linux
              CXX=g++
              RPATH="-Wl,-rpath,'\$ORIGIN'"
              ;;
            macOS)
              OUT=libOpenccWrapper.dylib
              LIB_DIR="${{ env.MACOS_ARM64_LIB_DIR }}"
              JINC=darwin
              CXX=clang++
              # keep loader_path rpath so it can load sibling dylibs if any remain
              RPATH="-Wl,-rpath,@loader_path"
              ;;
            *)
              echo "Unsupported OS: ${{ runner.os }}"; exit 1;;
          esac

          echo "Building on ${{ runner.os }}"
          echo " - OUT    : ${OUT}"
          echo " - LIB_DIR: ${LIB_DIR}"

          test -f "${{ env.CPP_SRC }}" || (echo "Missing CPP_SRC: ${{ env.CPP_SRC }}" && exit 1)
          test -d "${{ env.CAPI_INCLUDE }}" || (echo "Missing CAPI_INCLUDE: ${{ env.CAPI_INCLUDE }}" && exit 1)
          test -d "${LIB_DIR}" || (echo "Missing LIB_DIR: ${LIB_DIR}" && exit 1)

          # Prefer static archive if present
          # Linux/macOS static archive name convention: libopencc_fmmseg_capi.a
          STATIC_A="${LIB_DIR}/lib${{ env.CAPI_LIB_NAME }}.a"

          # Dynamic runtime names
          if [ "${{ runner.os }}" = "Linux" ]; then
            DYN_LIB="${LIB_DIR}/lib${{ env.CAPI_LIB_NAME }}.so"
          else
            DYN_LIB="${LIB_DIR}/lib${{ env.CAPI_LIB_NAME }}.dylib"
          fi

          LINK_FLAGS=""
          if [ -f "${STATIC_A}" ]; then
            echo "Using static link: ${STATIC_A}"
            # Link the archive directly (most deterministic)
            LINK_FLAGS="${STATIC_A}"
          else
            echo "Static archive not found; using dynamic link: ${DYN_LIB}"
            test -f "${DYN_LIB}" || (echo "Missing dynamic CAPI: ${DYN_LIB}" && exit 1)
            LINK_FLAGS="-L \"${LIB_DIR}\" -l${{ env.CAPI_LIB_NAME }} ${RPATH}"
          fi

          # Build output dir
          mkdir -p "artifacts/${{ runner.os }}"
          # Compile. Note: include '.' because javac -h wrote header into repo root (CWD)
          # and CAPI_INCLUDE has opencc_fmmseg_capi.h
          # shellcheck disable=SC2086
          ${CXX} -shared -fPIC -O2 -std=c++17 \
            -o "artifacts/${{ runner.os }}/${OUT}" \
            "${{ env.CPP_SRC }}" \
            -I . \
            -I "${JAVA_HOME}/include" \
            -I "${JAVA_HOME}/include/${JINC}" \
            -I "${{ env.CAPI_INCLUDE }}" \
            ${LINK_FLAGS}

          file "artifacts/${{ runner.os }}/${OUT}" || true
          echo "Built: artifacts/${{ runner.os }}/${OUT}"

          # Zip artifact (wrapper only; if you dynamically linked, your consumer still needs the CAPI dylib/so at runtime)
          (cd "artifacts/${{ runner.os }}" && zip -9 "OpenccJNI-natives-${{ runner.os }}.zip" "${OUT}")

      - name: Upload artifact (Linux/macOS)
        if: ${{ runner.os != 'Windows' }}
        uses: actions/upload-artifact@v4
        with:
          name: OpenccJNI-natives-${{ runner.os }}
          path: artifacts/${{ runner.os }}/OpenccJNI-natives-${{ runner.os }}.zip
          if-no-files-found: error

      - name: Windows note
        if: ${{ runner.os == 'Windows' }}
        shell: pwsh
        run: |
          Write-Host "Windows leg present but build is skipped in this workflow."
          Write-Host "Use your existing Windows toolchain job or keep shipping the prebuilt DLL."
