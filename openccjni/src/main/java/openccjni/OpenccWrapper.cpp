#include "opencc_fmmseg_capi.h"
#include "openccjni_OpenccWrapper.h"  // generated by `javac -h`
#include <string>
#include <cstring>

// Helper to read a Java byte[] into std::string (no copy back)
static std::string jbyteArrayToString(JNIEnv* env, jbyteArray array) {
    if (!array) return std::string();
    jsize length = env->GetArrayLength(array);
    jbyte* elements = env->GetByteArrayElements(array, nullptr);
    std::string s(reinterpret_cast<const char*>(elements), static_cast<size_t>(length));
    env->ReleaseByteArrayElements(array, elements, JNI_ABORT);
    return s;
}

JNIEXPORT jlong JNICALL Java_openccjni_OpenccWrapper_opencc_1new
  (JNIEnv* env, jobject /*obj*/) {
    return reinterpret_cast<jlong>(opencc_new());
}

JNIEXPORT jbyteArray JNICALL Java_openccjni_OpenccWrapper_opencc_1convert
  (JNIEnv* env, jobject /*obj*/, jlong instance, jbyteArray input, jbyteArray config, jboolean punctuation) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return nullptr;
    }
    // Convert inputs
    std::string inputStr  = jbyteArrayToString(env, input);
    std::string configStr = jbyteArrayToString(env, config);

    // Call native
    char* output = opencc_convert(
        reinterpret_cast<void*>(instance),
        inputStr.c_str(),
        configStr.c_str(),
        (punctuation == JNI_TRUE)   // coerce jboolean â†’ bool explicitly
    );

    // Marshal back to byte[]
    jbyteArray result = nullptr;
    if (output != nullptr) {
        const jsize outLen = static_cast<jsize>(std::strlen(output));
        result = env->NewByteArray(outLen);
        if (result != nullptr) {
            env->SetByteArrayRegion(result, 0, outLen, reinterpret_cast<const jbyte*>(output));
        }
        opencc_string_free(output);  // free native buffer
    }
    return result;
}

JNIEXPORT void JNICALL Java_openccjni_OpenccWrapper_opencc_1delete
  (JNIEnv* env, jobject /*obj*/, jlong instance) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return;
    }
    opencc_delete(reinterpret_cast<void*>(instance));
}

JNIEXPORT jint JNICALL Java_openccjni_OpenccWrapper_opencc_1zho_1check
  (JNIEnv* env, jobject /*obj*/, jlong instance, jbyteArray input) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return -1;
    }
    std::string inputStr = jbyteArrayToString(env, input);
    int code = opencc_zho_check(reinterpret_cast<void*>(instance), inputStr.c_str());
    return static_cast<jint>(code);
}

JNIEXPORT jboolean JNICALL Java_openccjni_OpenccWrapper_opencc_1get_1parallel
  (JNIEnv* env, jobject /*obj*/, jlong instance) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return JNI_FALSE;
    }
    return opencc_get_parallel(reinterpret_cast<void*>(instance)) ? JNI_TRUE : JNI_FALSE;
}

JNIEXPORT void JNICALL Java_openccjni_OpenccWrapper_opencc_1set_1parallel
  (JNIEnv* env, jobject /*obj*/, jlong instance, jboolean is_parallel) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return;
    }
    opencc_set_parallel(reinterpret_cast<void*>(instance), (is_parallel == JNI_TRUE));
}

JNIEXPORT jstring JNICALL Java_openccjni_OpenccWrapper_opencc_1last_1error
  (JNIEnv* env, jobject /*obj*/) {
    char* err = opencc_last_error();
    if (err == nullptr) return nullptr;
    jstring s = env->NewStringUTF(err); // assumes UTF-8
    opencc_error_free(err);
    return s;
}
