#include "opencc_fmmseg_capi.h"
#include "openccjni_OpenccWrapper.h"  // generated by `javac -h`
#include <string>
#include <cstring>
#include <optional>

// Helper to read a Java byte[] into std::string (no copy back).
// Returns std::nullopt when the array itself is null so callers can
// decide whether to proceed with native calls.
static std::optional<std::string> jbyteArrayToString(JNIEnv* env, jbyteArray array) {
    if (!array) return std::nullopt;
    jsize length = env->GetArrayLength(array);
    std::string s(static_cast<size_t>(length), '\0');
    if (length > 0) {
        env->GetByteArrayRegion(array, 0, length, reinterpret_cast<jbyte*>(s.data()));
        if (env->ExceptionCheck()) {
            return std::nullopt;
        }
    }
    return s;
}

JNIEXPORT jlong JNICALL Java_openccjni_OpenccWrapper_opencc_1new
  (JNIEnv* env, jobject /*obj*/) {
    return reinterpret_cast<jlong>(opencc_new());
}

JNIEXPORT jbyteArray JNICALL Java_openccjni_OpenccWrapper_opencc_1convert
  (JNIEnv* env, jobject /*obj*/, jlong instance, jbyteArray input, jbyteArray config, jboolean punctuation) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return nullptr;
    }
    // Convert inputs
    auto inputStrOpt  = jbyteArrayToString(env, input);
    auto configStrOpt = jbyteArrayToString(env, config);
    if (!inputStrOpt || !configStrOpt) {
        return nullptr;
    }

    // Call native
    char* output = opencc_convert(
        reinterpret_cast<void*>(instance),
        inputStrOpt->c_str(),
        configStrOpt->c_str(),
        (punctuation == JNI_TRUE)   // coerce jboolean â†’ bool explicitly
    );

    // Marshal back to byte[]
    jbyteArray result = nullptr;
    if (output != nullptr) {
        const jsize outLen = static_cast<jsize>(std::strlen(output));
        result = env->NewByteArray(outLen);
        if (result != nullptr) {
            env->SetByteArrayRegion(result, 0, outLen, reinterpret_cast<const jbyte*>(output));
        }
        opencc_string_free(output);  // free native buffer
    }
    return result;
}

JNIEXPORT jbyteArray JNICALL Java_openccjni_OpenccWrapper_opencc_1convert_1cfg
  (JNIEnv* env, jobject /*obj*/, jlong instance, jbyteArray input, jint config_id, jboolean punctuation) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) env->ThrowNew(exClass, "OpenCC instance is null");
        return nullptr;
    }

    auto inputStrOpt = jbyteArrayToString(env, input);
    if (!inputStrOpt) return nullptr;

    char* output = opencc_convert_cfg(
        reinterpret_cast<void*>(instance),
        inputStrOpt->c_str(),
        static_cast<opencc_config_t>(config_id),
        (punctuation == JNI_TRUE)
    );

    jbyteArray result = nullptr;
    if (output != nullptr) {
        const jsize outLen = static_cast<jsize>(std::strlen(output));
        result = env->NewByteArray(outLen);
        if (result != nullptr) {
            env->SetByteArrayRegion(result, 0, outLen, reinterpret_cast<const jbyte*>(output));
        }
        opencc_string_free(output);
    }
    return result;
}

JNIEXPORT void JNICALL Java_openccjni_OpenccWrapper_opencc_1delete
  (JNIEnv* env, jobject /*obj*/, jlong instance) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return;
    }
    opencc_delete(reinterpret_cast<void*>(instance));
}

JNIEXPORT jint JNICALL Java_openccjni_OpenccWrapper_opencc_1zho_1check
  (JNIEnv* env, jobject /*obj*/, jlong instance, jbyteArray input) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return -1;
    }
    auto inputStrOpt = jbyteArrayToString(env, input);
    if (!inputStrOpt) {
        return -1;
    }
    int code = opencc_zho_check(reinterpret_cast<void*>(instance), inputStrOpt->c_str());
    return static_cast<jint>(code);
}

JNIEXPORT jboolean JNICALL Java_openccjni_OpenccWrapper_opencc_1get_1parallel
  (JNIEnv* env, jobject /*obj*/, jlong instance) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return JNI_FALSE;
    }
    return opencc_get_parallel(reinterpret_cast<void*>(instance)) ? JNI_TRUE : JNI_FALSE;
}

JNIEXPORT void JNICALL Java_openccjni_OpenccWrapper_opencc_1set_1parallel
  (JNIEnv* env, jobject /*obj*/, jlong instance, jboolean is_parallel) {
    if (instance == 0) {
        jclass exClass = env->FindClass("java/lang/IllegalStateException");
        if (exClass != nullptr) {
            env->ThrowNew(exClass, "OpenCC instance is null");
        }
        return;
    }
    opencc_set_parallel(reinterpret_cast<void*>(instance), (is_parallel == JNI_TRUE));
}

JNIEXPORT jstring JNICALL Java_openccjni_OpenccWrapper_opencc_1last_1error
  (JNIEnv* env, jobject /*obj*/) {
    char* err = opencc_last_error();
    if (err == nullptr) return nullptr;
    jstring s = env->NewStringUTF(err); // assumes UTF-8
    opencc_error_free(err);
    return s;
}

JNIEXPORT jint JNICALL Java_openccjni_OpenccWrapper_opencc_1config_1name_1to_1id
  (JNIEnv* env, jobject /*obj*/, jbyteArray name_utf8) {
    auto nameOpt = jbyteArrayToString(env, name_utf8);
    if (!nameOpt) return static_cast<jint>(-1);

    opencc_config_t id{};
    bool ok = opencc_config_name_to_id(nameOpt->c_str(), &id);
    if (!ok) return static_cast<jint>(-1);

    return static_cast<jint>(id);
}

JNIEXPORT jbyteArray JNICALL Java_openccjni_OpenccWrapper_opencc_1config_1id_1to_1name
  (JNIEnv* env, jobject /*obj*/, jint config_id) {
    const char* name = opencc_config_id_to_name(static_cast<opencc_config_t>(config_id));
    if (name == nullptr) return nullptr;

    const jsize len = static_cast<jsize>(std::strlen(name));
    jbyteArray result = env->NewByteArray(len);
    if (result != nullptr) {
        env->SetByteArrayRegion(result, 0, len, reinterpret_cast<const jbyte*>(name));
    }
    return result;
}
